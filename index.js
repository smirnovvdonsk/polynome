/**
 * A polynome a+bx+cx²+dx³+... given by coefficients coeffs=[a,b,c,d...]
 * with methods of finding roots, interpolation, differentiation and more
 */
export default class Polynome {
	/**
	 * Creates a polynome
	 * @param {number[]} [coeffs] 
	 */
	constructor(coeffs = []) {
		this.coeffs = this.constructor.#removeZeroTail(coeffs.map(x => x))
	}


	/////// Constants
	/** Iterative calculation accuracy 
	 * @returns {number}
	 */
	static get TOLERANCE() { return 1e-15 }
	/** Iterative calculation accuracy (non-static)
	 * @returns {number}
	 */
	get TOLERANCE() { return this.constructor.TOLERANCE }



	/* STATIC METHODS  */

	/**
	 * Removes trailing zeroes from an array and returns a truncated array
	 * @param {number[]} array 
	 * @returns {number[]} 
	 */
	static #removeZeroTail(array) {
		if (!Array.isArray(array)) return [];
		while (array.length) {
			let last = array.pop();
			if (isNaN(+last) || (+last) === 0) {
				continue;
			} else {
				array.push(+last);
				break;
			};
		};
		return array;
	}

	/**
	 * Removes empty cells and cells with non-numeric data from an array and returns a truncated array 
	 * @param {number[]} array
	 * @returns {number[]}
	 */
	static #removeEmptySlots(array) {
		if (!Array.isArray(array)) return [];
		return array.filter(this.#isFloat);
	}

	/**
	 * Sorts an array in ascending order and removes non-numeric elements 
	 * @param {number[]} array 
	 * @returns {number[]} 
	 */
	static #sortArray(array) { return this.#removeEmptySlots(array).sort((a, b) => a - b) }

	/**
	 * Removes exact and approximate duplicates, as well as non-numeric elements, from a numeric array. Sorts an array 
	 * @param {number[]} array
	 * @returns {number[]}
	 */
	static #deduplicateArray(array) {
		if (!Array.isArray(array)) return [];
		let result = array;
		result = [...(new Set(result))]; // Remove exact duplicates 
		result = this.#sortArray(result); // Sort in ascending order and remove non-numeric elements 
		// Remove inaccurate duplicates 
		let dupIndexes = [];
		result.forEach((x, i, arr) => {
			let notFirst = (i > 0);
			let isDuplicateOfPrevious = (Math.abs(x - arr[i - 1]) <= this.TOLERANCE);
			if (notFirst && isDuplicateOfPrevious) dupIndexes.push(i);
		});
		dupIndexes.forEach(index => result[index] = undefined);
		result = result.filter(x => x !== undefined);
		return result;
	}

	/**
	 * Returns an instance. Takes as input an instance or an array of its coefficients 
	 * @param {(Object|number[])} polynome An instance of the polynome or an array of its coefficients 
	 * @returns {Object} An instance of the polynome
	 */
	static #polynomeFilter(polynome) {
		let obj;
		if (polynome.coeffs && Array.isArray(polynome.coeffs)) {
			obj = polynome;
		} else {
			if (Array.isArray(polynome)) {
				obj = new this(polynome)
			} else {
				obj = new this([])
			};
		};
		return obj;
	}

	/**
	 * Is the value a positive integer 
	 * @param {*} value 
	 * @returns {boolean}
	 */
	static #isPositiveInteger(value) { return (this.#isFloat(value) && (+value) > 0) }

	/**
	 * Is the value a number 
	 * @param {*} value 
	 * @returns {boolean}
	 */
	static #isFloat(value) { return !isNaN(+value) }

	/**
	 * Returns an instance generated by the Lagrange interpolation
	 * from  points [{x,y},{x,y},...]
	 * @param {Object[]} points An array of interpolation points 
	 * @param {number} points[].x Point abscissa
	 * @param {number} points[].y Point ordinate
	 * @returns {Object}
	 */
	static lagrangeInterpolate(points) {
		let result = new this([0]);
		points.forEach((p1, i) => {
			let P = new this([1]);
			let denom = 1;
			points.forEach((p2, j) => {
				if (j !== i) {
					P.mult([-p2.x, 1]);
					denom *= p1.x - p2.x;
				};
			});
			result.add(P.mult([p1.y / denom]));
		});
		return result;
	}



	/* NON-CHANGING METHODS  */

	/** Return an instance - a clone of this
	 * @returns {Object}
	 */
	get clone() { return new this.constructor(this.coeffs.map(x => x)) }

	/** Returns a new instance - the first derivative of this
	 * @returns {Object}
	 */
	get derivative() {
		let coeffs = this.coeffs.map((a, i) => a * i);
		coeffs.shift();
		this.constructor.#removeZeroTail(coeffs);
		return new this.constructor(coeffs);
	}


	/** Returns a new instance - the indefinite integral of this
	 * @returns {Object}
	 */
	get integral() {
		let coeffs = this.coeffs.map((a, i) => a / (i + 1));
		coeffs.unshift(0);
		this.constructor.#removeZeroTail(coeffs);
		return new this.constructor(coeffs);
	}

	/**
	 * Returns the value of the polynome at point x 
	 * @param {number} x Abscissa
	 * @returns {number}
	 */
	eval(x) {
		return this.coeffs
			.map((coeff, power) => coeff * Math.pow(x, power)) // an array of values for each member
			.reduce((a, b) => a + b, 0); // collapse the array by summation 
	}

	/**
	 * Returns an array of values of the polynome from given abscissas
	 * @param {number[]} xArray Abscissas
	 * @returns {number[]}
	 */
	evals(xArray) {
		return xArray.map(x => this.eval(x))
	}

	/**
	 * Returns an array of polynome's extremes (an array of abscissas in which the maximums and minimums of the polynome are observed) 
	 * @returns {number[]}
	 */
	get extremums() {
		return this.derivative.newtonRoots;
	}

	/**
	 * Returns an array of polynome's extremes (an array of abscissas in which the maximums and minimums of the polynome are observed) 
	 * @returns {number[]}
	 */
	get extremes() {
		return this.extremums;
	}

	/**
	 * Calculates by Newton's method the single root closest to x0 for which the polynome is zero
	 * @param {number} x0 Initial abscissa
	 * @returns {number}
	 */
	getNewtonRoot(x0 = 0.0) {
		const EPSILON = 1e-14;		// Do not divide by numbers less than this 
		const MAX_ITERATIONS = 256;	// Maximum number of iterations 
		let solutionFound = false;	// Solution not found yet 
		let result;
		if (isNaN(+x0)) return result;
		for (let i = 1; i <= MAX_ITERATIONS; i++) {
			let yprime = this.derivative.eval(x0);
			if (Math.abs(yprime) < EPSILON) break;
			result = x0 - this.eval(x0) / yprime;
			if (Math.abs(result - x0) <= this.TOLERANCE) {
				solutionFound = true;
				break;
			};
			x0 = result;
		};
		if (solutionFound) return result;
	}

	/**
	 * Calculates the roots (not all) of the polynome using Newton's method, trying everything in the xArray as initial values. 
	 * @param {number[]} [xArray=[0]] Array of initial abscissas
	 * @returns {number[]}
	 */
	getNewtonRoots(xArray = [0]) {
		let result = [];
		if (Array.isArray(xArray)) {
			if (xArray.length) {
				result = xArray.map(x => this.getNewtonRoot(x)); // Calculate all roots into an array 
			} else {
				result = [this.getNewtonRoot()]; // Calculate the root, closest to zero (we will use it later for recursive calculation of all roots)
			}
			result = this.constructor.#deduplicateArray(result); // Deduplication
		};
		return result;
	}

	/**
	 * Calculates by Newton's method all the roots of the polynome
	 * @returns {number[]}
	 */
	get newtonRoots() {
		// ATTENTION !!! This getter is recursive
		if (this.length < 2) return []; // Zero degree polynome has no roots
		if (this.length === 2) return this.getNewtonRoots(); // First degree polynome has no more than one root,
		// and it will be found for any initial values. 

		// To find the maximum number of roots, it need to specify more suitable initial values. 
		// To do this, create recursively all the derivatives of the polynome
		let derivative = this.derivative;
		let derivatives = []; // Array of derivatives 
		while (derivative.length > 1) { // up to first degree polynome
			derivatives.push(derivative);
			derivative = derivative.derivative; // Increasing the degree of the derivative 
		};
		// Find all roots of all derivatives. 
		let deriRoots = []; // An array of little arrays of roots of derivatives 
		// Attention !!! Next comes the recursion on this getter 
		derivatives.forEach(der => deriRoots.push(der.newtonRoots)); // [ [roots],[roots],[roots],[roots]..... ]
		deriRoots.forEach(roots => { // In each little array of roots:
			roots = this.constructor.#deduplicateArray(roots); // Sort and remove duplicates and garbage
			// Now between each two neighbor roots we add a median
			let medians = [];
			roots.forEach((root, i, arr) => {
				if (i !== 0) medians.push((root + arr[i - 1]) / 2);
			});
			roots.push(...medians);
			roots = this.constructor.#deduplicateArray(roots); // Sort and remove duplicates and garbage
		});
		deriRoots = deriRoots.flat() // Smash little arrays
		deriRoots = this.constructor.#deduplicateArray(deriRoots); // Sort and remove duplicates and garbage
		// From the far left root, add one a little to the left, from the far right - a little to the right 
		if (deriRoots.length) {
			deriRoots.unshift(deriRoots[0] - 2 * this.TOLERANCE);
			let last = deriRoots.pop(); deriRoots.push(last);
			deriRoots.push(last + 2 * this.TOLERANCE);
		};
		return this.getNewtonRoots(deriRoots);
	}

	/**
	 * Get all the roots of the polynome
	 * @returns {number[]}
	 */
	get roots() {
		return this.newtonRoots;
	}


	/* CHANGING METHODS  */


	/////// The degree of the polynome (the length of its array minus one) 

	/**
	 * Changes the length of the array. When increasing, appends zeroes to the tail 
	 * @param {number} value New length
	 * @returns {Object}
	 */
	setLength(value) {
		if (this.constructor.#isPositiveInteger(value)) {
			let coeffs = this.coeffs;
			this.coeffs = Array(+value).fill(0).map((zero, i) => coeffs[i] || zero);
		};
		return this;
	}
	/**
	 * Changes the length of the array. When increasing, appends zeroes to the tail
	 * @param {number} value New length
	 * @returns {Object}
	 */
	setSize(value) { return this.setLength(value) }
	/**
	 * The length of the array
	 * @returns {number}
	 */
	get length() { return this.coeffs.length }
	/**
	 * Changes the length of the array. When increasing, appends zeroes to the tail
	 * @param {number} value New length
	 */
	set length(value) { this.setLength(value) }
	/**
	 * The length of the array
	 * @returns {number}
	 */
	get size() { return this.length }
	/**
	 * Changes the length of the array. When increasing, appends zeroes to the tail
	 * @param {number} value New length
	 */
	set size(value) { this.length = value }

	/**
	 * The degree of the polynome
	 * @returns {number}
	 */
	get degree() { return this.length - 1 }
	/**
	 * Changes the degree of the polynome. When increasing, appends zeroes to the tail
	 * @param {number} value New degree
	 */
	set degree(value) { this.length = value + 1 }

	/**
	 * Makes this polynome the interpolation product and returns it
	 * @param {Object[]} points Array of interpolation points 
	 * @param {number} points[].x Point abscissa
	 * @param {number} points[].y Point ordinate
	 * @returns {Object}
	 */
	lagrangeInterpolate(points) { // look at the static method with the same name
		this.coeffs = this.constructor.lagrangeInterpolate(points).coeffs;
		return this;
	}

	/**
	 * Adds another polynome to this polynome. For example, [a,b,c] + [x,y] => [a+x,b+y,c+0] 
	 * @param {(Object|number[])} polynome 
	 * @returns {Object}
	 */
	add(polynome) {
		let poly = this.constructor.#polynomeFilter(polynome);
		this.length = poly.length = Math.max(this.length, poly.length);
		this.coeffs = this.coeffs.map((item, index) => item + poly.coeffs[index]);
		return this;
	}

	/**
	 * Subtracts another polynome from this polynome. For example, [a,b,c] - [x,y] => [a-x,b-y,c-0] 
	 * @param {(Object|number[])} polynome 
	 * @returns {Object}
	 */
	sub(polynome) {
		let poly = this.constructor.#polynomeFilter(polynome);
		this.length = poly.length = Math.max(this.length, poly.length);
		this.coeffs = this.coeffs.map((item, index) => item - poly.coeffs[index]);
		return this;
	}

	/**
	 * Multiplies this polynome by another polynome. For example, (a+bx+cx²+dx³+...)(p+qx+rx²+sx³+...) given as ([a,b,c,d],[p,q,r,s ]) 
	 * @param {(Object|number[])} polynome 
	 * @returns {Object}
	 */
	mult(polynome) {
		let poly = this.constructor.#polynomeFilter(polynome);
		let resultLength = this.length + poly.length - 1;
		let result = Array(resultLength).fill(0);
		this.coeffs.forEach((a, i) => {
			poly.coeffs.forEach((b, j) => {
				result[i + j] += a * b;
			});
		});
		this.coeffs = result;
		return this;
	}
};

